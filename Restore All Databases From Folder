USE [master]
GO
/****** Object:  StoredProcedure [dbo].[sp_RestoreFromAllFilesInDirectory]    Script Date: 5/24/2022 1:33:58 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE OR ALTER PROCEDURE [dbo].[sp_RestoreFromAllFilesInDirectory] @DatabaseName nvarchar(500) = NULL,
															@BackupFiles NVARCHAR(500), 
                                                           @DataFile1       NVARCHAR(500) = NULL, 
                                                           @DataFile2      NVARCHAR(500) = NULL, 
                                                           @DataFile3      NVARCHAR(500) = NULL, 
                                                           @DataFile4      NVARCHAR(500) = NULL, 
                                                           @DataFile5      NVARCHAR(500) = NULL, 
                                                           @DataFile6      NVARCHAR(500) = NULL, 
														   @DataFile7      NVARCHAR(500) = NULL, 
                                                           @LogFile      NVARCHAR(500) = NULL, 
                                                           @BackupInLastXDays    INT           = 7, 
                                                           @MaxBackupSizeInGB    INT           = 500, 
                                                           @PrintOnly            BIT           = 0, --1 prints command, 0 execute script
														   @DropDatabase		 BIT			= 0,
														   @DeleteBackupFile	 BIT			= 0,
														   @RunCheckDB			 BIT		    = 1	,
														   	@BufferCount INT = NULL,
	@MaxTransferSize INT = NULL,
	@BlockSize INT = NULL,
	@runrecovery bit = 1
AS
   
/*
EXEC [dbo].[sp_RestoreFromAllFilesInDirectory]
		@BackupFiles  = N'U:\,V:\'
		,@DataFile1 = N'J:\SQLData\' --Must Pass this parameter for largest data drive size
		,@DataFile2 = N'K:\SQLData\' --If parameter is not passed than it will restore all data file to above data drive in this case J drive
		,@DataFile3 = N'M:\SQLData\'
		,@DataFile4 = N'N:\SQLData\'
		,@DataFile5 = N'G:\SQLData\'
		,@DataFile6 = N'H:\SQLData\'
		,@DataFile7 = N'S:\SQLData\'
		,@LogFile = N'I:\SQLData\'  --Must pass this parameter for log file drive location
		,@BackupInLastXDays = 99 --Restore maximum 7 days old backup
		,@MaxBackupSizeInGB = 10000
		,@deletebackupfile = 0
		,@runcheckdb = 1
		,@printonly = 0
		,@runrecovery = 1
		,@BufferCount = 24
		,@MaxTransferSize = 4194304
		,@blocksize = 4096

*/

     SET NOCOUNT ON;

	 IF NOT @MaxTransferSize IS NULL
BEGIN
	IF @MaxTransferSize > 4194304
	BEGIN
		RAISERROR('@MaxTransferSize can not be greater then 4194304', 0, 1) WITH NOWAIT;
	END

	IF @MaxTransferSize % 64 <> 0
	BEGIN
		RAISERROR('@MaxTransferSize has to be a multiple of 65536', 0, 1) WITH NOWAIT;
	END
END;

IF NOT @BlockSize IS NULL
BEGIN
	IF @BlockSize NOT IN (512, 1024, 2048, 4096, 8192, 16384, 32768, 65536)
	BEGIN
		RAISERROR('Supported values for @BlockSize are 512, 1024, 2048, 4096, 8192, 16384, 32768, and 65536', 0, 1) WITH NOWAIT;
	END
END

declare @BackupParameters nvarchar(max) = ''

	IF NOT @BufferCount IS NULL
	BEGIN
		SET @BackupParameters += N', BufferCount=' + cast(@BufferCount as NVARCHAR(10))
	END

	IF NOT @MaxTransferSize IS NULL
	BEGIN
		SET @BackupParameters += N', MaxTransferSize=' + cast(@MaxTransferSize as NVARCHAR(7))
	END

	IF NOT @BlockSize IS NULL
	BEGIN
		SET @BackupParameters += N', BlockSize=' + cast(@BlockSize as NVARCHAR(5))
	END

	if @runrecovery = 0
	begin
	set @BackupParameters += N' , NORECOVERY'
	end

	 DECLARE @TotalDrives int
     IF @DataFile1 IS NULL
         SET @DataFile1 = CONVERT(NVARCHAR(500), SERVERPROPERTY('InstanceDefaultDataPath'));
		 	 set @totaldrives = count(@DataFile1) + count(@DataFile2) + count(@DataFile3) + count(@DataFile4) + count(@DataFile5) + count(@DataFile6) + count(@DataFile7) 
    IF @LogFile IS NULL
         SET @LogFile = CONVERT(NVARCHAR(500), SERVERPROPERTY('InstanceDefaultLogPath'));
     IF @DataFile7 IS NULL
         SET @DataFile7 = isnull(@DataFile6, isnull(@DataFile5, isnull(@DataFile4, isnull(@DataFile3, isnull(@DataFile2, @DataFile1)))))
		 --SELECT @DataFile7 , @TotalDrives
DECLARE @crlf CHAR(2)= CHAR(13) + CHAR(10);
	 declare @StartTime datetime
     --Table to hold each backup file name in
	 create table #xpfixeddrives (drive varchar(100), MBFree bigint)
	 insert into #xpfixeddrives
	 exec xp_fixeddrives

	select full_filesystem_path as dir, level as depth, '1' as isfile,file_or_directory_name as fname Into #files
	 from string_split(@BackupFiles,',') a cross apply sys.dm_os_enumerate_filesystem(a.value,'*') 
	 where size_in_bytes <> 0 and last_write_time > (DATEADD(year,-7,getdate()))
		and file_or_directory_name like '%bak' and full_filesystem_path not like '%recycle%'

     --Table to hold the result from RESTORE HEADERONLY. Needed to get the database name out from

     DECLARE @BackupDT DATETIME;
     DECLARE @sql nVARCHAR(MAX);
     DECLARE @ProductVersion NVARCHAR(128);
     DECLARE @ProductVersionNumber TINYINT;
     SET @ProductVersion = CONVERT(NVARCHAR(128), SERVERPROPERTY('ProductVersion'));
     SET @ProductVersionNumber = SUBSTRING(@ProductVersion, 1, (CHARINDEX('.', @ProductVersion) - 1));
     IF OBJECT_ID('dbo.tblBackupHeader') IS NOT NULL
         DROP TABLE dbo.tblBackupHeader;
     SET @sql = '';

     -- THIS IS GENERIC FOR SQL SERVER 2008R2, 2012 and 2014

     CREATE TABLE #bdev
     (BackupName             NVARCHAR(128), 
      BackupDescription      NVARCHAR(255), 
      BackupType             SMALLINT, 
      ExpirationDate         DATETIME, 
      Compressed             TINYINT, 
      Position               SMALLINT, 
      DeviceType             TINYINT, 
      UserName               NVARCHAR(128), 
      ServerName             NVARCHAR(128), 
      DatabaseName           NVARCHAR(128), 
      DatabaseVersion        BIGINT, 
      DatabaseCreationDate   DATETIME, 
      BackupSize             NUMERIC(20, 0), 
      FirstLSN               NUMERIC(25, 0), 
      LastLSN                NUMERIC(25, 0), 
      CheckpointLSN          NUMERIC(25, 0), 
      DatabaseBackupLSN      NUMERIC(25, 0), 
      BackupStartDate        DATETIME, 
      BackupFinishDate       DATETIME, 
      SortOrder              SMALLINT, 
      [CodePage]             SMALLINT, 
      UnicodeLocaleId        BIGINT, 
      UnicodeComparisonStyle BIGINT, 
      CompatibilityLevel     TINYINT, 
      SoftwareVendorId       BIGINT, 
      SoftwareVersionMajor   BIGINT, 
      SoftwareVersionMinor   BIGINT, 
      SoftwareVersionBuild   BIGINT, 
      MachineName            NVARCHAR(128), 
      Flags                  BIGINT, 
      BindingID              UNIQUEIDENTIFIER, 
      RecoveryForkID         UNIQUEIDENTIFIER, 
      Collation              NVARCHAR(128), 
      FamilyGUID             UNIQUEIDENTIFIER, 
      HasBulkLoggedData      BIGINT, 
      IsSnapshot             BIGINT, 
      IsReadOnly             BIGINT, 
      IsSingleUser           BIGINT, 
      HasBackupChecksums     BIGINT, 
      IsDamaged              BIGINT, 
      BeginsLogChain         BIGINT, 
      HasIncompleteMetaData  BIGINT, 
      IsForceOffline         BIGINT, 
      IsCopyOnly             BIGINT, 
      FirstRecoveryForkID    UNIQUEIDENTIFIER, 
      ForkPointLSN           NUMERIC(25, 0), 
      RecoveryModel          NVARCHAR(128), 
      DifferentialBaseLSN    NUMERIC(25, 0), 
      DifferentialBaseGUID   UNIQUEIDENTIFIER, 
      BackupTypeDescription  NVARCHAR(128), 
      BackupSetGUID          UNIQUEIDENTIFIER, 
      CompressedBackupSize   BIGINT
     );
	 DECLARE @CompressedBackupSize BIGINT;
     IF CAST(CAST(SERVERPROPERTY('ProductVersion') AS CHAR(4)) AS FLOAT) = 11 -- Greater than SQL 2005 
         BEGIN
             ALTER TABLE #bdev
             ADD Containment BIGINT;
         END;
     IF CAST(CAST(SERVERPROPERTY('ProductVersion') AS CHAR(4)) AS FLOAT) >= 12 -- Greater than SQL 2005 
         BEGIN
             ALTER TABLE #bdev
             ADD Containment         BIGINT, 
                 KeyAlgorithm        NVARCHAR(32), 
                 EncryptorThumbprint VARBINARY(20), 
                 EncryptorType       NVARCHAR(32);
         END;
     ALTER TABLE #bdev
     ADD Seq INT NOT NULL IDENTITY(1, 1);
     CREATE TABLE #restoreLabel
     (MediaName            NVARCHAR(128), 
      MediaSetId           UNIQUEIDENTIFIER, 
      FamilyCount          INT, 
      FamilySequenceNumber INT, 
      MediaFamilyId        UNIQUEIDENTIFIER, 
      MediaSequenceNumber  INT, 
      MediaLabelPresent    TINYINT, 
      MediaDescription     NVARCHAR(255), 
      SoftwareName         NVARCHAR(128), 
      SoftwareVendorId     INT, 
      MediaDate            DATETIME, 
      Mirror_Count         INT, 
      IsCompressed         BIT
     );

     --Table to hold result from RESTORE FILELISTONLY. Need to generate the MOVE options to the RESTORE command

     CREATE TABLE #dbfiles
     (LogicalName          NVARCHAR(128), 
      PhysicalName         NVARCHAR(260), 
      [Type]               CHAR(1), 
      FileGroupName        NVARCHAR(128) NULL, 
      Size                 NUMERIC(20, 0), 
      MaxSize              NUMERIC(20, 0), 
      FileID               BIGINT, 
      CreateLSN            NUMERIC(25, 0), 
      DropLSN              NUMERIC(25, 0) NULL, 
      UniqueID             UNIQUEIDENTIFIER, 
      ReadOnlyLSN          NUMERIC(25, 0) NULL, 
      ReadWriteLSN         NUMERIC(25, 0) NULL, 
      BackupSizeInBytes    BIGINT, 
      SourceBlockSize      INT, 
      FileGroupID          INT, 
      LogGroupGUID         UNIQUEIDENTIFIER NULL, 
      DifferentialBaseLSN  NUMERIC(25, 0) NULL, 
      DifferentialBaseGUID UNIQUEIDENTIFIER NULL, 
      IsReadOnly           BIT, 
      IsPresent            BIT
     );
     IF CAST(CAST(SERVERPROPERTY('ProductVersion') AS CHAR(4)) AS FLOAT) > 9 -- Greater than SQL 2005 
         BEGIN
             ALTER TABLE #dbfiles
             ADD TDEThumbprint VARBINARY(32) NULL;
         END;
     IF CAST(CAST(SERVERPROPERTY('ProductVersion') AS CHAR(2)) AS FLOAT) > 12 -- Greater than 2014
         BEGIN
             ALTER TABLE #dbfiles
             ADD SnapshotURL NVARCHAR(360) NULL;
         END;
     CREATE TABLE [#multifilerestore]
     ([MediaName]            [NVARCHAR](128) NULL, 
      [MediaSetId]           [UNIQUEIDENTIFIER] NULL, 
      [FamilyCount]          [INT] NULL, 
      [FamilySequenceNumber] [INT] NULL, 
      [MediaFamilyId]        [UNIQUEIDENTIFIER] NULL, 
      [MediaSequenceNumber]  [INT] NULL, 
      [MediaLabelPresent]    [TINYINT] NULL, 
      [MediaDescription]     [NVARCHAR](255) NULL, 
      [SoftwareName]         [NVARCHAR](128) NULL, 
      [SoftwareVendorId]     [INT] NULL, 
      [MediaDate]            [DATETIME] NULL, 
      [Mirror_Count]         [INT] NULL, 
      [IsCompressed]         [BIT] NULL, 
      [BackupLocation]       [VARCHAR](300) NULL, 
      [Scripts]              [NVARCHAR](MAX), 
	  DBName				nvarchar(500),
	  CompressedBackupSize					bigint,
      TimeRun                DATETIME DEFAULT GETDATE()
     )
     ON [PRIMARY] TEXTIMAGE_ON [PRIMARY];
     DECLARE @fname VARCHAR(200);
     DECLARE @dirfile VARCHAR(300);
     DECLARE @LogicalName NVARCHAR(128);
     DECLARE @PhysicalName NVARCHAR(260);
     DECLARE @type CHAR(1);
     DECLARE @DbName SYSNAME;
     DECLARE @Size NUMERIC(35, 0), @fileid BIGINT;
	-- select * from #files
     DECLARE files CURSOR
     FOR SELECT Dir
         FROM #files
         WHERE Dir LIKE '%.bak'
               AND DIR NOT LIKE '%master%'
               AND DIR NOT LIKE '%msdb%'
               AND DIR NOT LIKE '%zdba%'
               AND DIR NOT LIKE '%model%'
               AND DIR NOT LIKE '%pubs%'
               AND DIR NOT LIKE '%ag_test%'
               AND DIR NOT LIKE '%view_test%';
     DECLARE dbfiles CURSOR
     FOR SELECT LogicalName, 
                PhysicalName, 
                Type, 
                size, 
                FileId
         FROM #dbfiles
         ORDER BY type, 
                  size DESC;

     --select * from #dbfiles
     OPEN files;
     FETCH NEXT FROM files INTO @fname;
     WHILE @@FETCH_STATUS = 0
         BEGIN
             SET @dirfile = @fname;

             --Get database name from RESTORE HEADERONLY, assumes there's only one backup on each backup file.
             TRUNCATE TABLE #bdev;
			 BEGIN TRY
             INSERT INTO #bdev
             EXEC ('RESTORE HEADERONLY FROM DISK = '''+@dirfile+'''');
			 END TRY
			 BEGIN CATCH
	 INSERT INTO master.dbo.CommandLog (DatabaseName, SchemaName, ObjectName, ObjectType, IndexName, IndexType, StatisticsName, PartitionNumber, ExtendedInfo, CommandType, Command, StartTime,EndTime,ErrorNumber,ErrorMessage)
    VALUES (ISNULL(@DbName,''), convert(varchar(30),@CompressedBackupSize), null, null, null, null, null, null, null, 'Restore header FAILED',  isnull( @dirfile,''), isnull(@StartTime,GETDATE()),getdate(), ERROR_NUMBER(),ERROR_message())
	END CATCH 
             --SELECT *
             --FROM #bdev;
             SET @DbName =
             (
                 SELECT TOP 1 DatabaseName
                 FROM #bdev
                 WHERE BackupStartDate > DATEADD(dd, -@BackupInLastXDays, GETDATE())
                       AND CompressedBackupSize / (1024 * 1024 * 1024) < @MaxBackupSizeInGB
                       AND BackupType = 1
					   AND DatabaseName LIKE ISNULL(@DatabaseName,'%')
                 ORDER BY BackupStartDate DESC
             );
			 SET @CompressedBackupSize = ( SELECT  TOP 1 CompressedBackupSize FROM #bdev)
             TRUNCATE TABLE #restorelabel;
			 begin try
             INSERT INTO #restoreLabel
             EXEC ('RESTORE labelonly FROM DISK = '''+@dirfile+'''');
	 END TRY
			 BEGIN CATCH
	Print 'Restore LabelOnly failed'
	END CATCH 
             --Construct the beginning for the RESTORE DATABASE command
             SET @sql = 'RESTORE DATABASE [' + @DbName + '] ' + @crlf + 'FROM DISK = ''' + @dirfile + '''' + @crlf + ' WITH REPLACE' + @crlf + ',STATS = 5' + @BackupParameters + @crlf + ',MOVE ';
             --select * from #dbfiles
             --Get information about database files from backup device into temp table
             TRUNCATE TABLE #dbfiles;
			 BEGIN TRY
             INSERT INTO #dbfiles
             EXEC ('RESTORE FILELISTONLY FROM DISK = '''+@dirfile+'''');
			 END TRY
	BEGIN CATCH
	 Print 'Restore FilelistOnly failed'
	END CATCH 
             --SELECT *
             --FROM #dbfiles
             --ORDER BY type, 
             --         size DESC;
 
             OPEN dbfiles;
             DECLARE @count INT= 1;
             --For each database file that the database uses
             WHILE 1 = 1
                 BEGIN
                     FETCH NEXT FROM dbfiles INTO @LogicalName, @PhysicalName, @type, @size, @fileid;
                     --select @LogicalName, @PhysicalName, @type, @size,@fileid

                     IF @@FETCH_STATUS <> 0
                         BREAK;
                     IF @type = 'D'
                         BEGIN
                             IF ( @count%@TotalDrives = 1 )
                                 BEGIN
                                     SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DataFile1 + @LogicalName + '.mdf''' + @crlf;
                                     SET @sql = @sql + ' ,MOVE ';
                                 END;
                                 ELSE
                             IF ( @count%@TotalDrives = 2 )
                                     BEGIN
                                         SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DataFile2 + @LogicalName + '.mdf ''' + @crlf;
                                         SET @sql = @sql + ' ,MOVE ';
                                     END;
                                     ELSE
                                                          IF ( @count%@TotalDrives = 3 )
            BEGIN
                                             SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DataFile3 + @LogicalName + '.mdf ''' + @crlf;
                                             SET @sql = @sql + ' ,MOVE ';
                                         END;
                                         ELSE
                                                                    IF ( @count%@TotalDrives = 4 )

                                             BEGIN
                                                 SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DataFile4 + @LogicalName + '.mdf ''' + @crlf;
                                                 SET @sql = @sql + ' ,MOVE ';
                                             END;
                                             ELSE
                                                                      IF ( @count%@TotalDrives = 5 )

                                                 BEGIN
                                                     SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DataFile5 + @LogicalName + '.mdf ''' + @crlf;
                                                     SET @sql = @sql + ' ,MOVE ';
                                                 END;
                                                 ELSE
                                                                       IF ( @count%@TotalDrives = 6 )

                                                     BEGIN
                                                         SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DataFile6 + @LogicalName + '.mdf ''' + @crlf;
                                                         SET @sql = @sql + ' ,MOVE ';
                                                     END;
                                                     ELSE
                                                     BEGIN
                                                        SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DataFile7 + @LogicalName + '.mdf ''' + @crlf;
                                                         SET @sql = @sql + ' ,MOVE ';
                                                     END;
                         END;
                         ELSE
                         IF @type = 'L'
                             BEGIN
                                 SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @LogFile + @LogicalName + '.ldf''' + @crlf;
                                 SET @sql = @sql + ' ,MOVE ';
                             END;
                             ELSE
                             IF @type = 'S'
                                 SET @sql = @sql + ', MOVE ' + '''' + @LogicalName + ''' TO ''' + @DataFile1 + @LogicalName + '''' + @crlf;
                     SET @count = @count + 1;
                 END;
             SET @sql = LEFT(@sql, LEN(@sql) - 5) + @crlf;

             --Here's the actual RESTORE command 
             IF EXISTS
             (
                 SELECT 1
                 FROM #restoreLabel
                 WHERE FamilyCount = 1
             )
                 BEGIN
                     IF @PrintOnly = 1
                         PRINT @sql; 
                         --Remove the comment below if you want the procedure to actually execute the restore command. 
                         ELSE
						 begin 
						 set @StartTime = GETDATE()
						 BEGIN TRY
                         EXEC (@sql);
						 waitfor delay '00:00:01'
						  INSERT INTO master.dbo.CommandLog (DatabaseName, SchemaName, ObjectName, ObjectType, IndexName, IndexType, StatisticsName, PartitionNumber, ExtendedInfo, CommandType, Command, StartTime,EndTime,ErrorNumber,ErrorMessage)
    VALUES (@DbName, convert(varchar(30),@CompressedBackupSize), null, null, null, null, null, null, null, 'Restore completed', @sql, @StartTime,getdate(), ERROR_NUMBER(),ERROR_message())
if @RunCheckDB = 1
begin
EXECUTE dbo.DatabaseIntegrityCheck
@Databases = @dbname,
@CheckCommands = 'CheckDB',
@LogToTable = 'Y';
end
	END TRY
	BEGIN CATCH
	 INSERT INTO master.dbo.CommandLog (DatabaseName, SchemaName, ObjectName, ObjectType, IndexName, IndexType, StatisticsName, PartitionNumber, ExtendedInfo, CommandType, Command, StartTime,EndTime,ErrorNumber,ErrorMessage)
    VALUES (@DbName, convert(varchar(30),@CompressedBackupSize), null, null, null, null, null, null, null, 'Restore FAILED', @sql, isnull(@StartTime,GETDATE()),getdate(), ERROR_NUMBER(),ERROR_message())
	END CATCH 
						 end
                     SET @sql = 'drop database ' + QUOTENAME(@dbname);
                     IF @PrintOnly = 1
                         PRINT @sql;
                         ELSE if @DropDatabase = 1
						 begin try
                         EXEC sp_executesql 
                              @sql;
							  	 END TRY
			 BEGIN CATCH
	 INSERT INTO master.dbo.CommandLog (DatabaseName, SchemaName, ObjectName, ObjectType, IndexName, IndexType, StatisticsName, PartitionNumber, ExtendedInfo, CommandType, Command, StartTime,EndTime,ErrorNumber,ErrorMessage)
    VALUES (@DbName, convert(varchar(30),@CompressedBackupSize), null, null, null, null, null, null, null, 'Drop database FAILED',  isnull( @sql,''), isnull(@StartTime,GETDATE()),getdate(), ERROR_NUMBER(),ERROR_message())
	END CATCH 
                     WAITFOR DELAY '00:00:01';
                     IF @PrintOnly = 1
                         PRINT '--exec xp_delete_file 0,''' + @dirfile + '''';
                         ELSE if @DeleteBackupFile = 1
						exec xp_delete_file 0, @dirfile;
                  END;
                 ELSE
                 BEGIN
                     --PRINT 'this file is multi backup restore ' + @dirfile + @sql;
                     INSERT INTO [#multifilerestore]
                            SELECT *, 
                                   @dirfile BackupLocation, 
                                   @sql Scripts,
								   @DbName, 
								   @CompressedBackupSize,
                                   GETDATE()
                            FROM #restoreLabel;
                 END;
             CLOSE dbfiles;
             FETCH NEXT FROM files INTO @fname;
         END;
     CLOSE files;
     DEALLOCATE dbfiles;
     DEALLOCATE files;
     DECLARE multirestore CURSOR
     FOR SELECT DISTINCT 
                replace(scripts, '''' + backuplocation + '''', SUBSTRING(
         (
             SELECT DISTINCT
                    (', DISK = ''' + backuplocation + '''')
             FROM [#multifilerestore] b
             WHERE a.mediasetid = b.mediasetid FOR XML PATH('')
         ), 9, 8000)), DBName, CompressedBackupSize 
         FROM [#multifilerestore] a
         WHERE familysequencenumber = 1
               AND Scripts IS NOT NULL;

     --select * from #dbfiles
     OPEN multirestore;
     FETCH NEXT FROM multirestore INTO @sql, @DBName, @CompressedBackupSize;
     WHILE @@FETCH_STATUS = 0
         BEGIN
             IF @PRINTONLY = 1
                 PRINT @SQL;
                 ELSE
				 BEGIN 
				 begin try
				 set @StartTime = GETDATE()
                 EXEC sp_executesql 
                      @sql;
					   waitfor delay '00:00:01'
						  INSERT INTO master.dbo.CommandLog (DatabaseName, SchemaName, ObjectName, ObjectType, IndexName, IndexType, StatisticsName, PartitionNumber, ExtendedInfo, CommandType, Command, StartTime,EndTime,ErrorNumber,ErrorMessage)
    VALUES (@DbName,  convert(varchar(30),@CompressedBackupSize), null, null, null, null, null, null, null, 'Restore completed', @sql, @StartTime, getdate(), ERROR_NUMBER(),ERROR_message())
if @RunCheckDB = 1
begin
EXECUTE dbo.DatabaseIntegrityCheck
@Databases = @dbname,
@CheckCommands = 'CheckDB',
@LogToTable = 'Y'
end
		 END TRY
			 BEGIN CATCH
	 INSERT INTO master.dbo.CommandLog (DatabaseName, SchemaName, ObjectName, ObjectType, IndexName, IndexType, StatisticsName, PartitionNumber, ExtendedInfo, CommandType, Command, StartTime,EndTime,ErrorNumber,ErrorMessage)
    VALUES (@DbName, convert(varchar(30),@CompressedBackupSize), null, null, null, null, null, null, null, 'Multifile Restore FAILED', isnull( @sql,''), isnull(@StartTime,GETDATE()),getdate(), ERROR_NUMBER(),ERROR_message())
	END CATCH 
	end
             FETCH NEXT FROM multirestore INTO @sql,@dbname, @CompressedBackupSize;
         END;
     CLOSE multirestore;
     DEALLOCATE multirestore;
     DROP TABLE #multifilerestore;

/*
--Copy all backups from multiple folders to one folder.
Set-Location U:\Backups\SmallDB
Get-ChildItem -Path "U:\Backups\SmallDB\*.bak" -Recurse | Move-Item -Destination "U:\Backups\SmallDB\"

$tdc="U:\Backups\SmallDB"
do {
  $dirs = gci $tdc -directory -recurse | Where { (gci $_.fullName).count -eq 0 } | select -expandproperty FullName
  $dirs | Foreach-Object { Remove-Item $_ }
} while ($dirs.count -gt 0)

--Robocopy "\\mycompany\SQL-BACKUPS\" U:\Backups\SmallDB *.bak /MAX:10000000000 /MAXAGE:7 /S /XF "*master*" "*msdb*" "*zDBA*" "*model*" "*pubs*" "*ag_test*" "*view_test*"
*/
