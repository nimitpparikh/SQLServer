--https://karaszi.com/restore-all-databases-from-a-number-of-backup-files
--Below is code for SQL 2016 and SQL 2017, for lower version you can check above website.
--Below code is just copy from above website, I have tested it works fine on SQL 2017 restore.

--https://karaszi.com/restore-all-databases-from-a-number-of-backup-files
--Below is code for SQL 2016 and SQL 2017, for lower version you can check above website.
--Below code is just copy from above website, I have tested it works fine on SQL 2017 restore.
USE master
GO
/****** Object:  StoredProcedure [dbo].[sp_RestoreFromAllFilesInDirectory]    Script Date: 1/4/2022 6:58:38 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[sp_RestoreFromAllFilesInDirectory] @SourceDirBackupFiles NVARCHAR(200), 
                                                          @DestDirDbFiles       NVARCHAR(200), 
                                                          @Dest2DirDbFiles      NVARCHAR(200) = NULL, 
                                                          @Dest3DirDbFiles      NVARCHAR(200) = NULL, 
                                                          @Dest4DirDbFiles      NVARCHAR(200) = NULL, 
                                                          @Dest5DirDbFiles      NVARCHAR(200) = NULL, 
                                                          @Dest6DirDbFiles      NVARCHAR(200) = NULL, 
                                                          @DestDirLogFiles      NVARCHAR(200), 
                                                          @BackupInLastXDays    INT           = 7, 
                                                          @MaxBackupSizeInGB    INT           = 10, 
                                                          @PrintOnly            BIT           = 1 --1 prints command, 0 execute script
AS
     --Originally written by Tibor Karaszi 2004. Use at own risk. 
     --Restores from all files in a certain directory. Assumes that: 
     --  There's only one backup on each backup device. 
     --  Each database uses only two database files and the mdf file is returned first from the RESTORE FILELISTONLY command. 
     --Sample execution: 
/*
EXEC [dbo].[sp_RestoreFromAllFilesInDirectory]
		@SourceDirBackupFiles = N'\\dc1.greendotcorp.com\dfs\dc1-sql-backups\NRTDBVCLUSAG\',
		@DestDirDbFiles = N'J:\SQLData\', --Must Pass this parameter for largest data drive size
		@Dest2DirDbFiles = N'K:\SQLData\', --If parameter is not passed than it will restore all data file to above data drive in this case J drive
		@Dest3DirDbFiles = N'M:\SQLData\',
		@Dest4DirDbFiles = N'N:\SQLData\',
		@Dest5DirDbFiles = N'G:\SQLData\',
		@Dest6DirDbFiles = N'H:\SQLData\',
		@DestDirLogFiles = N'I:\SQLData\',  --Must pass this parameter for log file drive location
		@BackupInLastXDays = 7, --Restore maximum 7 days old backup
		@MaxBackupSizeInGB = 10 --Max compressed backup size 10GB
*/
/*
EXEC sp_RestoreFromAllFilesInDirectory 
@SourceDirBackupFiles = 'J:\Backup\',
@DestDirDbFiles = 'J:\SQLData\' ,
@DestDirLogFiles ='I:\SQLData\'
--Default max 10GB backup will be restore, backup should be done in last 7 days, you can change this values as needed.
*/

     --Modified 2016-12-19:
     -- Works for SQL Server 2016
     -- Added linebreaks for readability
     -- Create physical file name from logical file name, not database name
     -- Supports multiple database file, thanks to above
     -- Added stats f√∂r every 5 %
     SET NOCOUNT ON;
     IF @Dest2DirDbFiles IS NULL
         SET @Dest2DirDbFiles = @DestDirDbFiles;
     IF @Dest3DirDbFiles IS NULL
         SET @Dest3DirDbFiles = @DestDirDbFiles;
     IF @Dest4DirDbFiles IS NULL
         SET @Dest4DirDbFiles = @DestDirDbFiles;
     IF @Dest5DirDbFiles IS NULL
         SET @Dest5DirDbFiles = @DestDirDbFiles;
     IF @Dest6DirDbFiles IS NULL
         SET @Dest6DirDbFiles = @DestDirDbFiles;
     DECLARE @crlf CHAR(2)= CHAR(13) + CHAR(10);

     --Table to hold each backup file name in
     CREATE TABLE #dirtree
     (Dir    VARCHAR(256), 
      Depth  TINYINT, 
      IsFile BIT, 
      ID     INT IDENTITY(1, 1) PRIMARY KEY
     );
     CREATE TABLE #fulltree
     (Dir    VARCHAR(256), 
      Depth  TINYINT, 
      IsFile BIT, 
      Parent INT, 
      ID     INT
      PRIMARY KEY
     );
     INSERT INTO #dirtree
     (Dir, 
      Depth, 
      IsFile
     )
     EXEC master.sys.xp_dirtree 
          @SourceDirBackupFiles, 
          0, 
          1;
     INSERT INTO #fulltree
     (Dir, 
      Depth, 
      IsFile, 
      Parent, 
      ID
     )
            SELECT Dir, 
                   Depth, 
                   IsFile, 
                   p.MID AS Parent, 
                   ID
            FROM #dirtree AS d WITH(NOLOCK)
                 OUTER APPLY
            (
                SELECT MAX(ID) AS MID
                FROM #dirtree AS i WITH(NOLOCK)
                WHERE i.Depth + 1 = d.Depth
                      AND i.ID < d.ID
            ) AS p;
     CREATE NONCLUSTERED INDEX #fulltree_parent ON #fulltree([Parent]);
     WITH RecCTE
          AS (SELECT CAST(@SourceDirBackupFiles + Dir AS VARCHAR(MAX)) AS Dir, 
                     Depth, 
                     ID, 
                     IsFile, 
                     Dir AS FName
              FROM #fulltree
              WHERE Parent IS NULL
              UNION ALL
              SELECT CAST(p.Dir + '\' + d.Dir AS VARCHAR(MAX)), 
                     d.Depth, 
                     d.ID, 
                     d.IsFile, 
                     d.Dir AS FName
              FROM #fulltree AS d
                   INNER JOIN RecCTE AS p ON d.Parent = p.ID)
          SELECT Dir, 
                 Depth, 
                 IsFile, 
                 FName
          INTO #files
          FROM RecCTE
          WHERE isfile = 1
          ORDER BY ID;
     DROP TABLE #dirtree;
     DROP TABLE #fulltree;
     --Table to hold the result from RESTORE HEADERONLY. Needed to get the database name out from

     DECLARE @BackupDT DATETIME;
     DECLARE @sql VARCHAR(MAX);
     DECLARE @ProductVersion NVARCHAR(128);
     DECLARE @ProductVersionNumber TINYINT;
     SET @ProductVersion = CONVERT(NVARCHAR(128), SERVERPROPERTY('ProductVersion'));
     SET @ProductVersionNumber = SUBSTRING(@ProductVersion, 1, (CHARINDEX('.', @ProductVersion) - 1));
     IF OBJECT_ID('dbo.tblBackupHeader') IS NOT NULL
         DROP TABLE dbo.tblBackupHeader;
     SET @sql = '';

     -- THIS IS GENERIC FOR SQL SERVER 2008R2, 2012 and 2014

     CREATE TABLE #bdev
     (BackupName             NVARCHAR(128), 
      BackupDescription      NVARCHAR(255), 
      BackupType             SMALLINT, 
      ExpirationDate         DATETIME, 
      Compressed             TINYINT, 
      Position               SMALLINT, 
      DeviceType             TINYINT, 
      UserName               NVARCHAR(128), 
      ServerName             NVARCHAR(128), 
      DatabaseName           NVARCHAR(128), 
      DatabaseVersion        BIGINT, 
      DatabaseCreationDate   DATETIME, 
      BackupSize             NUMERIC(20, 0), 
      FirstLSN               NUMERIC(25, 0), 
      LastLSN                NUMERIC(25, 0), 
      CheckpointLSN          NUMERIC(25, 0), 
      DatabaseBackupLSN      NUMERIC(25, 0), 
      BackupStartDate        DATETIME, 
      BackupFinishDate       DATETIME, 
      SortOrder              SMALLINT, 
      [CodePage]             SMALLINT, 
      UnicodeLocaleId        BIGINT, 
      UnicodeComparisonStyle BIGINT, 
      CompatibilityLevel     TINYINT, 
      SoftwareVendorId       BIGINT, 
      SoftwareVersionMajor   BIGINT, 
      SoftwareVersionMinor   BIGINT, 
      SoftwareVersionBuild   BIGINT, 
      MachineName            NVARCHAR(128), 
      Flags                  BIGINT, 
      BindingID              UNIQUEIDENTIFIER, 
      RecoveryForkID         UNIQUEIDENTIFIER, 
      Collation              NVARCHAR(128), 
      FamilyGUID             UNIQUEIDENTIFIER, 
      HasBulkLoggedData      BIGINT, 
      IsSnapshot             BIGINT, 
      IsReadOnly             BIGINT, 
      IsSingleUser           BIGINT, 
      HasBackupChecksums     BIGINT, 
      IsDamaged              BIGINT, 
      BeginsLogChain         BIGINT, 
      HasIncompleteMetaData  BIGINT, 
      IsForceOffline         BIGINT, 
      IsCopyOnly             BIGINT, 
      FirstRecoveryForkID    UNIQUEIDENTIFIER, 
      ForkPointLSN           NUMERIC(25, 0), 
      RecoveryModel          NVARCHAR(128), 
      DifferentialBaseLSN    NUMERIC(25, 0), 
      DifferentialBaseGUID   UNIQUEIDENTIFIER, 
      BackupTypeDescription  NVARCHAR(128), 
      BackupSetGUID          UNIQUEIDENTIFIER, 
      CompressedBackupSize   BIGINT
     );
     IF CAST(CAST(SERVERPROPERTY('ProductVersion') AS CHAR(4)) AS FLOAT) = 11 -- Greater than SQL 2005 
         BEGIN
             ALTER TABLE #bdev
             ADD Containment BIGINT;
         END;
     IF CAST(CAST(SERVERPROPERTY('ProductVersion') AS CHAR(4)) AS FLOAT) >= 12 -- Greater than SQL 2005 
         BEGIN
             ALTER TABLE #bdev
             ADD Containment         BIGINT, 
                 KeyAlgorithm        NVARCHAR(32), 
                 EncryptorThumbprint VARBINARY(20), 
                 EncryptorType       NVARCHAR(32);
         END;
     ALTER TABLE #bdev
     ADD Seq INT NOT NULL IDENTITY(1, 1);
     CREATE TABLE #restoreLabel
     (MediaName            NVARCHAR(128), 
      MediaSetId           UNIQUEIDENTIFIER, 
      FamilyCount          INT, 
      FamilySequenceNumber INT, 
      MediaFamilyId        UNIQUEIDENTIFIER, 
      MediaSequenceNumber  INT, 
      MediaLabelPresent    TINYINT, 
      MediaDescription     NVARCHAR(255), 
      SoftwareName         NVARCHAR(128), 
      SoftwareVendorId     INT, 
      MediaDate            DATETIME, 
      Mirror_Count         INT, 
      IsCompressed         BIT
     );

     --Table to hold result from RESTORE FILELISTONLY. Need to generate the MOVE options to the RESTORE command

     CREATE TABLE #dbfiles
     (LogicalName          NVARCHAR(128), 
      PhysicalName         NVARCHAR(260), 
      [Type]               CHAR(1), 
      FileGroupName        NVARCHAR(128) NULL, 
      Size                 NUMERIC(20, 0), 
      MaxSize              NUMERIC(20, 0), 
      FileID               BIGINT, 
      CreateLSN            NUMERIC(25, 0), 
      DropLSN              NUMERIC(25, 0) NULL, 
      UniqueID             UNIQUEIDENTIFIER, 
      ReadOnlyLSN          NUMERIC(25, 0) NULL, 
      ReadWriteLSN         NUMERIC(25, 0) NULL, 
      BackupSizeInBytes    BIGINT, 
      SourceBlockSize      INT, 
      FileGroupID          INT, 
      LogGroupGUID         UNIQUEIDENTIFIER NULL, 
      DifferentialBaseLSN  NUMERIC(25, 0) NULL, 
      DifferentialBaseGUID UNIQUEIDENTIFIER NULL, 
      IsReadOnly           BIT, 
      IsPresent            BIT
     );
     IF CAST(CAST(SERVERPROPERTY('ProductVersion') AS CHAR(4)) AS FLOAT) > 9 -- Greater than SQL 2005 
         BEGIN
             ALTER TABLE #dbfiles
             ADD TDEThumbprint VARBINARY(32) NULL;
         END;
     IF CAST(CAST(SERVERPROPERTY('ProductVersion') AS CHAR(2)) AS FLOAT) > 12 -- Greater than 2014
         BEGIN
             ALTER TABLE #dbfiles
             ADD SnapshotURL NVARCHAR(360) NULL;
         END;
     CREATE TABLE [#multifilerestore]
     ([MediaName]            [NVARCHAR](128) NULL, 
      [MediaSetId]           [UNIQUEIDENTIFIER] NULL, 
      [FamilyCount]          [INT] NULL, 
      [FamilySequenceNumber] [INT] NULL, 
      [MediaFamilyId]        [UNIQUEIDENTIFIER] NULL, 
      [MediaSequenceNumber]  [INT] NULL, 
      [MediaLabelPresent]    [TINYINT] NULL, 
      [MediaDescription]     [NVARCHAR](255) NULL, 
      [SoftwareName]         [NVARCHAR](128) NULL, 
      [SoftwareVendorId]     [INT] NULL, 
      [MediaDate]            [DATETIME] NULL, 
      [Mirror_Count]         [INT] NULL, 
      [IsCompressed]         [BIT] NULL, 
      [BackupLocation]       [VARCHAR](300) NULL, 
      [Scripts]              [NVARCHAR](MAX), 
      TimeRun                DATETIME DEFAULT GETDATE()
     )
     ON [PRIMARY] TEXTIMAGE_ON [PRIMARY];
     DECLARE @fname VARCHAR(200);
     DECLARE @dirfile VARCHAR(300);
     DECLARE @LogicalName NVARCHAR(128);
     DECLARE @PhysicalName NVARCHAR(260);
     DECLARE @type CHAR(1);
     DECLARE @DbName SYSNAME;
     DECLARE @Size NUMERIC(35, 0), @fileid BIGINT;
     DECLARE files CURSOR
     FOR SELECT Dir
         FROM #files
         WHERE Dir LIKE '%.bak'
               AND DIR NOT LIKE '%master%'
               AND DIR NOT LIKE '%msdb%'
               AND DIR NOT LIKE '%zdba%'
               AND DIR NOT LIKE '%model%'
               AND DIR NOT LIKE '%pubs%'
               AND DIR NOT LIKE '%ag_test%'
               AND DIR NOT LIKE '%view_test%';
     DECLARE dbfiles CURSOR
     FOR SELECT LogicalName, 
                PhysicalName, 
                Type, 
                size, 
                FileId
         FROM #dbfiles
         ORDER BY type, 
                  size DESC;

     --select * from #dbfiles
     OPEN files;
     FETCH NEXT FROM files INTO @fname;
     WHILE @@FETCH_STATUS = 0
         BEGIN
             SET @dirfile = @fname;

             --Get database name from RESTORE HEADERONLY, assumes there's only one backup on each backup file.
             TRUNCATE TABLE #bdev;
             INSERT INTO #bdev
             EXEC ('RESTORE HEADERONLY FROM DISK = '''+@dirfile+'''');
             --SELECT *
             --FROM #bdev;
             SET @DbName =
             (
                 SELECT TOP 1 DatabaseName
                 FROM #bdev
                 WHERE BackupStartDate > DATEADD(dd, -@BackupInLastXDays, GETDATE())
                       AND CompressedBackupSize / (1024 * 1024 * 1024) < @MaxBackupSizeInGB
                       AND BackupType = 1
				ORDER BY BackupStartDate ASC
             );
             TRUNCATE TABLE #restorelabel;
             INSERT INTO #restoreLabel
             EXEC ('RESTORE labelonly FROM DISK = '''+@dirfile+'''');

             --Construct the beginning for the RESTORE DATABASE command
             SET @sql = 'RESTORE DATABASE [' + @DbName + '] ' + @crlf + 'FROM DISK = ''' + @dirfile + '''' + @crlf + ' WITH REPLACE' + @crlf + ',STATS = 5 ' + @crlf + ',MOVE ';
             --select * from #dbfiles
             --Get information about database files from backup device into temp table
             TRUNCATE TABLE #dbfiles;
             INSERT INTO #dbfiles
             EXEC ('RESTORE FILELISTONLY FROM DISK = '''+@dirfile+'''');

             --SELECT *
             --FROM #dbfiles
             --ORDER BY type, 
             --         size DESC;
             OPEN dbfiles;
             DECLARE @count INT= 1;
             --For each database file that the database uses
             WHILE 1 = 1
                 BEGIN
                     FETCH NEXT FROM dbfiles INTO @LogicalName, @PhysicalName, @type, @size, @fileid;
                     --select @LogicalName, @PhysicalName, @type, @size,@fileid

                     IF @@FETCH_STATUS <> 0
                         BREAK;
                     IF @type = 'D'
                         BEGIN
                             IF @count IN(1, 8, 14, 21, 22, 29, 30)
                                 BEGIN
                                     SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DestDirDbFiles + @LogicalName + '.mdf ''' + @crlf;
                                     SET @sql = @sql + ' ,MOVE ';
                                 END;
                                 ELSE
                                 IF @count IN(2, 9, 15, 20, 23, 28, 31)
                                     BEGIN
                                         SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest2DirDbFiles + @LogicalName + '.mdf ''' + @crlf;
                                         SET @sql = @sql + ' ,MOVE ';
                                     END;
                                     ELSE
                                     IF(@count IN(3, 10, 16, 19, 24, 27, 32))
                                         BEGIN
                                             SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest3DirDbFiles + @LogicalName + '.mdf ''' + @crlf;
                                             SET @sql = @sql + ' ,MOVE ';
                                         END;
                                         ELSE
                                         IF(@count IN(4, 11, 17, 18, 25, 26))
                                             BEGIN
                                                 SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest4DirDbFiles + @LogicalName + '.mdf ''' + @crlf;
                                                 SET @sql = @sql + ' ,MOVE ';
                                             END;
                                             ELSE
                                             IF(@count IN(5, 12))
                                                 BEGIN
                                                     SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest5DirDbFiles + @LogicalName + '.mdf ''' + @crlf;
                                                     SET @sql = @sql + ' ,MOVE ';
                                                 END;
                                                 ELSE
                                                 IF(@count IN(6, 13))
                                                     BEGIN
                                                         SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest6DirDbFiles + @LogicalName + '.mdf ''' + @crlf;
                                                         SET @sql = @sql + ' ,MOVE ';
                                                     END;
                                                     ELSE
                                                     BEGIN
                                                         SET @sql = @sql + '''' + @LogicalName + ''' TO ''S:\SQLData\' + @LogicalName + '.mdf ''' + @crlf;
                                                         SET @sql = @sql + ' ,MOVE ';
                                                     END;
                         END;
                         ELSE
                         IF @type = 'L'
                             BEGIN
                                 SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DestDirLogFiles + @LogicalName + '.ldf''' + @crlf;
                                 SET @sql = @sql + ' ,MOVE ';
                             END;
                             ELSE
                             IF @type = 'S'
                                 SET @sql = @sql + ', MOVE ' + '''' + @LogicalName + ''' TO ''' + @DestDirDbFiles + @LogicalName + '''' + @crlf;
                     SET @count = @count + 1;
                 END;
             SET @sql = LEFT(@sql, LEN(@sql) - 5) + @crlf;

             --Here's the actual RESTORE command 
             IF EXISTS
             (
                 SELECT 1
                 FROM #restoreLabel
                 WHERE FamilyCount = 1
             )
                 BEGIN
                     IF @PrintOnly = 1
                         PRINT @sql; 
                         --Remove the comment below if you want the procedure to actually execute the restore command. 
                         ELSE
                         EXEC (@sql);
                     WAITFOR DELAY '00:00:01';
                     SET @sql = '--drop database ' + QUOTENAME(@dbname);
                     IF @PrintOnly = 1
                         PRINT @sql;
                         ELSE
                         EXEC sp_executesql 
                              @sql;
                     WAITFOR DELAY '00:00:01';
                     IF @PrintOnly = 1
                         PRINT '--exec xp_delete_file 0,''' + @dirfile + '''';
                         ELSE
                         EXEC xp_delete_file 
                              0, 
                              @dirfile;
                 END;
                 ELSE
                 BEGIN
                     --PRINT 'this file is multi backup restore ' + @dirfile + @sql;
                     INSERT INTO [#multifilerestore]
                            SELECT *, 
                                   @dirfile BackupLocation, 
                                   @sql Scripts, 
                                   GETDATE()
                            FROM #restoreLabel;
                 END;
             CLOSE dbfiles;
             FETCH NEXT FROM files INTO @fname;
         END;
     CLOSE files;
     DEALLOCATE dbfiles;
     DEALLOCATE files;
     DECLARE multirestore CURSOR
     FOR SELECT DISTINCT 
                replace(scripts, '''' + backuplocation + '''', SUBSTRING(
         (
             SELECT DISTINCT
                    (', DISK = ''' + backuplocation + '''')
             FROM [#multifilerestore] b
             WHERE a.mediasetid = b.mediasetid FOR XML PATH('')
         ), 9, 8000))
         FROM [#multifilerestore] a
         WHERE familysequencenumber = 1
               AND Scripts IS NOT NULL;

     --select * from #dbfiles
     OPEN multirestore;
     FETCH NEXT FROM multirestore INTO @sql;
     WHILE @@FETCH_STATUS = 0
         BEGIN
             IF @PRINTONLY = 1
                 PRINT @SQL;
                 ELSE
                 EXEC sp_executesql 
                      @sql;
             FETCH NEXT FROM multirestore INTO @sql;
         END;
     CLOSE multirestore;
     DEALLOCATE multirestore;
     DROP TABLE #multifilerestore;

/*
--Copy all backups from multiple folders to one folder.
Set-Location U:\Backups\SmallDB
Get-ChildItem -Path "U:\Backups\SmallDB\*.bak" -Recurse | Move-Item -Destination "U:\Backups\SmallDB\"

$tdc="U:\Backups\SmallDB"
do {
  $dirs = gci $tdc -directory -recurse | Where { (gci $_.fullName).count -eq 0 } | select -expandproperty FullName
  $dirs | Foreach-Object { Remove-Item $_ }
} while ($dirs.count -gt 0)

--Robocopy "\\mycompany\SQL-BACKUPS\" U:\Backups\SmallDB *.bak /MAX:10000000000 /MAXAGE:7 /S /XF "*master*" "*msdb*" "*zDBA*" "*model*" "*pubs*" "*ag_test*" "*view_test*"
*/
