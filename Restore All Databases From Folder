--https://karaszi.com/restore-all-databases-from-a-number-of-backup-files
--Below is code for SQL 2016 and SQL 2017, for lower version you can check above website.
--Below code is just copy from above website, I have tested it works fine on SQL 2017 restore.

--https://karaszi.com/restore-all-databases-from-a-number-of-backup-files
--Below is code for SQL 2016 and SQL 2017, for lower version you can check above website.
--Below code is just copy from above website, I have tested it works fine on SQL 2017 restore.
USE master
GO
/****** Object:  StoredProcedure [dbo].[sp_RestoreFromAllFilesInDirectory]    Script Date: 1/4/2022 6:58:38 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE PROCEDURE [dbo].[sp_RestoreFromAllFilesInDirectory]
@SourceDirBackupFiles nvarchar(200), @DestDirDbFiles nvarchar(200),@Dest2DirDbFiles nvarchar(200) = NULL, @Dest3DirDbFiles nvarchar(200) = NULL, @Dest4DirDbFiles nvarchar(200) = NULL,
@Dest5DirDbFiles nvarchar(200) = NULL, @Dest6DirDbFiles nvarchar(200) = NULL, @DestDirLogFiles nvarchar(200)
, @BackupInLastXDays int = 7, @MaxBackupSizeInGB int = 10 
AS
--Originally written by Tibor Karaszi 2004. Use at own risk. 
--Restores from all files in a certain directory. Assumes that: 
--  There's only one backup on each backup device. 
--  Each database uses only two database files and the mdf file is returned first from the RESTORE FILELISTONLY command. 
--Sample execution: 
/*
EXEC [dbo].[sp_RestoreFromAllFilesInDirectory]
		@SourceDirBackupFiles = N'\\dc1.greendotcorp.com\dfs\dc1-sql-backups\NRTDBVCLUSAG\',
		@DestDirDbFiles = N'J:\SQLData\', --Must Pass this parameter for largest data drive size
		@Dest2DirDbFiles = N'K:\SQLData\', --If parameter is not passed than it will restore all data file to above data drive in this case J drive
		@Dest3DirDbFiles = N'M:\SQLData\',
		@Dest4DirDbFiles = N'N:\SQLData\',
		@Dest5DirDbFiles = N'G:\SQLData\',
		@Dest6DirDbFiles = N'H:\SQLData\',
		@DestDirLogFiles = N'I:\SQLData\',  --Must pass this parameter for log file drive location
		@BackupInLastXDays = 7, --Restore maximum 7 days old backup
		@MaxBackupSizeInGB = 10 --Max compressed backup size 10GB
*/
/*
EXEC sp_RestoreFromAllFilesInDirectory 
@SourceDirBackupFiles = 'J:\Backup\',
@DestDirDbFiles = 'J:\SQLData\' ,
@DestDirLogFiles ='I:\SQLData\'
--Default max 10GB backup will be restore, backup should be done in last 7 days, you can change this values as needed.
*/
--Modified 2016-12-19:
-- Works for SQL Server 2016
-- Added linebreaks for readability
-- Create physical file name from logical file name, not database name
-- Supports multiple database file, thanks to above
-- Added stats f√∂r every 5 %
SET NOCOUNT ON

If @Dest2DirDbFiles is null 
set @Dest2DirDbFiles = @DestDirDbFiles
if @Dest3DirDbFiles is null
set @Dest3DirDbFiles = @DestDirDbFiles
if @Dest4DirDbFiles is null
set @Dest4DirDbFiles = @DestDirDbFiles
if @Dest5DirDbFiles is null
set @Dest5DirDbFiles = @DestDirDbFiles
if @Dest6DirDbFiles is null
set @Dest6DirDbFiles = @DestDirDbFiles
DECLARE @crlf char(2) = CHAR(13) + CHAR(10)

--Table to hold each backup file name in
CREATE TABLE #dirtree (
 Dir VARCHAR(256), 
 Depth TinyInt, 
 IsFile Bit, 
 ID INT IDENTITY(1,1) PRIMARY KEY);

CREATE TABLE #fulltree (
 Dir VARCHAR(256), 
 Depth TinyInt, 
 IsFile Bit, 
 Parent INT, 
 ID INT PRIMARY KEY);
INSERT INTO #dirtree(Dir, Depth, IsFile) 
EXEC master.sys.xp_dirtree @SourceDirBackupFiles,0,1;
INSERT INTO #fulltree(Dir, Depth, IsFile, Parent, ID)
SELECT Dir, Depth, IsFile, p.MID as Parent, ID
FROM #dirtree as d WITH (NOLOCK)
OUTER APPLY (SELECT MAX(ID) as MID FROM #dirtree as i WITH (NOLOCK)
 WHERE i.Depth + 1 = d.Depth and i.ID < d.ID ) as p;
CREATE NONCLUSTERED INDEX #fulltree_parent ON #fulltree([Parent])
;WITH RecCTE as (
 SELECT CAST(@SourceDirBackupFiles + Dir as VARCHAR(MAX)) as Dir
  , Depth, ID, IsFile, Dir as FName
 FROM #fulltree WHERE Parent is Null
 UNION ALL
 SELECT CAST(p.Dir + '\' + d.Dir as VARCHAR(MAX))
  , d.Depth, d.ID, d.IsFile, d.Dir as FName
 FROM #fulltree as d INNER JOIN RecCTE as p ON d.Parent = p.ID
) SELECT Dir, Depth, IsFile, FName into #files FROM RecCTE where isfile = 1 ORDER BY ID
drop table #dirtree
drop table #fulltree
--Table to hold the result from RESTORE HEADERONLY. Needed to get the database name out from
CREATE TABLE #bdev(
BackupName nvarchar(128) 
,BackupDescription nvarchar(255) 
,BackupType smallint
,ExpirationDate datetime
,Compressed tinyint
,Position smallint
,DeviceType tinyint
,UserName nvarchar(128) 
,ServerName nvarchar(128) 
,DatabaseName nvarchar(128) 
,DatabaseVersion bigint
,DatabaseCreationDate datetime
,BackupSize numeric(20,0)
,FirstLSN numeric(25,0)
,LastLSN numeric(25,0)
,CheckpointLSN numeric(25,0)
,DatabaseBackupLSN numeric(25,0)
,BackupStartDate datetime
,BackupFinishDate datetime
,SortOrder smallint
,[CodePage] smallint
,UnicodeLocaleId bigint
,UnicodeComparisonStyle bigint
,CompatibilityLevel tinyint
,SoftwareVendorId bigint
,SoftwareVersionMajor bigint
,SoftwareVersionMinor bigint
,SoftwareVersionBuild bigint
,MachineName nvarchar(128) 
,Flags bigint
,BindingID uniqueidentifier
,RecoveryForkID uniqueidentifier
,Collation nvarchar(128) 
,FamilyGUID uniqueidentifier
,HasBulkLoggedData bigint
,IsSnapshot bigint
,IsReadOnly bigint
,IsSingleUser bigint
,HasBackupChecksums bigint
,IsDamaged bigint
,BegibsLogChain bigint
,HasIncompleteMetaData bigint
,IsForceOffline bigint
,IsCopyOnly bigint
,FirstRecoveryForkID uniqueidentifier
,ForkPointLSN numeric(25,0)
,RecoveryModel nvarchar(128) 
,DifferentialBaseLSN numeric(25,0)
,DifferentialBaseGUID uniqueidentifier
,BackupTypeDescription nvarchar(128) 
,BackupSetGUID uniqueidentifier
,CompressedBackupSize bigint
,Containment bigint
,KeyAlgorithm nvarchar(32)
,EncryptorThumbprint varbinary(20)
,EncryptorType nvarchar(23)
)
CREATE TABLE #restoreLabel(
MediaName	nvarchar(128),
MediaSetId	uniqueidentifier,
FamilyCount	int	,
FamilySequenceNumber	int,
MediaFamilyId	uniqueidentifier,
MediaSequenceNumber	int,
MediaLabelPresent	tinyint,
MediaDescription	nvarchar(255),
SoftwareName	nvarchar(128),
SoftwareVendorId	int	,
MediaDate	datetime,
Mirror_Count	int,
IsCompressed	bit)


--Table to hold result from RESTORE FILELISTONLY. Need to generate the MOVE options to the RESTORE command
CREATE TABLE #dbfiles(
LogicalName nvarchar(128) 
,PhysicalName nvarchar(260) 
,[Type] char(1) 
,FileGroupName nvarchar(128) 
,Size numeric(20,0)
,MaxSize numeric(20,0)
,FileId bigint
,CreateLSN numeric(25,0)
,DropLSN numeric(25,0)
,UniqueId uniqueidentifier
,ReadOnlyLSN numeric(25,0)
,ReadWriteLSN numeric(25,0)
,BackupSizeInBytes bigint
,SourceBlockSize bigint
,FilegroupId bigint
,LogGroupGUID uniqueidentifier
,DifferentialBaseLSN numeric(25)
,DifferentialBaseGUID uniqueidentifier
,IsReadOnly bigint
,IsPresent int 
,TDEThumbprint uniqueidentifier
,SnapshotUrl nvarchar(360)
)

CREATE TABLE [#multifilerestore](
	[MediaName] [nvarchar](128) NULL,
	[MediaSetId] [uniqueidentifier] NULL,
	[FamilyCount] [int] NULL,
	[FamilySequenceNumber] [int] NULL,
	[MediaFamilyId] [uniqueidentifier] NULL,
	[MediaSequenceNumber] [int] NULL,
	[MediaLabelPresent] [tinyint] NULL,
	[MediaDescription] [nvarchar](255) NULL,
	[SoftwareName] [nvarchar](128) NULL,
	[SoftwareVendorId] [int] NULL,
	[MediaDate] [datetime] NULL,
	[Mirror_Count] [int] NULL,
	[IsCompressed] [bit] NULL,
	[BackupLocation] [varchar](300) NULL,
	[Scripts] [nvarchar](max) ,
	TimeRun datetime default getdate()
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

DECLARE @fname varchar(200) 
DECLARE @dirfile varchar(300) 
DECLARE @LogicalName nvarchar(128) 
DECLARE @PhysicalName nvarchar(260) 
DECLARE @type char(1) 
DECLARE @DbName sysname 
DECLARE @sql nvarchar(max) , @Size numeric(20,0), @fileid bigint;

DECLARE files CURSOR FOR
SELECT Dir FROM #files
where Dir like '%.bak' and DIR not like '%master%'
and DIR not like '%msdb%'
and DIR not like '%zdba%'
and DIR not like '%model%'
and DIR not like '%pubs%'
and DIR not like '%ag_test%'
and DIR not like '%view_test%'

DECLARE dbfiles CURSOR FOR
SELECT LogicalName, PhysicalName, Type, size, FileId FROM #dbfiles
order by type, size desc

--select * from #dbfiles
OPEN files
FETCH NEXT FROM files INTO @fname
WHILE @@FETCH_STATUS = 0
BEGIN
SET @dirfile = @fname

--Get database name from RESTORE HEADERONLY, assumes there's only one backup on each backup file.
TRUNCATE TABLE #bdev
INSERT #bdev
EXEC('RESTORE HEADERONLY FROM DISK = ''' + @dirfile + '''') 
SET @DbName = (SELECT DatabaseName FROM #bdev where BackupStartDate > DATEADD(dd,-@BackupInLastXDays,getdate()) and CompressedBackupSize/(1024*1024*1024) < @MaxBackupSizeInGB)


TRUNCATE TABLE #restorelabel
INSERT #restoreLabel
EXEC('RESTORE labelonly FROM DISK = ''' + @dirfile + '''')

--Construct the beginning for the RESTORE DATABASE command
SET @sql = 'RESTORE DATABASE [' + @DbName + '] ' + @crlf 
+ 'FROM DISK = ''' + @dirfile + '''' + @crlf 
+ ' WITH REPLACE' + @crlf 
+ ',STATS = 5 ' + @crlf 
+ ',MOVE '
--select * from #dbfiles
--Get information about database files from backup device into temp table
TRUNCATE TABLE #dbfiles
INSERT #dbfiles
EXEC('RESTORE FILELISTONLY FROM DISK = ''' + @dirfile + '''')

--select * from #bdev
--select * from #files
select * from #dbfiles
order by type, size desc
OPEN dbfiles
declare @count int = 1
--For each database file that the database uses
WHILE 1 = 1
BEGIN
	FETCH NEXT FROM dbfiles INTO @LogicalName, @PhysicalName, @type, @size, @fileid
	--select @LogicalName, @PhysicalName, @type, @size,@fileid
	
	IF @@FETCH_STATUS <> 0 
		BREAK
	IF @type = 'D'
	BEGIN
		if @count in ( 1,8,14,21,22,29,30)
		begin 
	  SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DestDirDbFiles + @LogicalName + '.mdf '''  + @crlf
	  SET @sql = @sql + ' ,MOVE '
	  end
	  else if @count in (2, 9,15,20,23,28,31)
	  begin
	    SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest2DirDbFiles + @LogicalName + '.mdf ''' + @crlf
	  SET @sql = @sql + ' ,MOVE '
	  end
	  else  if ( @count in ( 3,10,16,19,24,27,32))
	  begin
	    SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest3DirDbFiles + @LogicalName + '.mdf '''  + @crlf
	  SET @sql = @sql + ' ,MOVE '
	  end
	  else  if ( @count in ( 4,11,17,18,25,26))
	  begin
	    SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest4DirDbFiles + @LogicalName + '.mdf ''' + @crlf
	  SET @sql = @sql + ' ,MOVE '
	  end
	    else  if ( @count in ( 5,12) )
	  begin
	    SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest5DirDbFiles + @LogicalName + '.mdf ''' + @crlf
	  SET @sql = @sql + ' ,MOVE '
	  end
	    else  if ( @count in ( 6,13) )
	  begin
	    SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @Dest6DirDbFiles + @LogicalName + '.mdf ''' + @crlf
	  SET @sql = @sql + ' ,MOVE '
	  end
	    else  
	  begin
	    SET @sql = @sql + '''' + @LogicalName + ''' TO ''S:\SQLData\' + @LogicalName + '.mdf ''' + @crlf
	  SET @sql = @sql + ' ,MOVE '
	  end
END
	ELSE IF @type = 'L'
	begin
	  SET @sql = @sql + '''' + @LogicalName + ''' TO ''' + @DestDirLogFiles + @LogicalName + '.ldf''' + @crlf
	   SET @sql = @sql + ' ,MOVE '
	   end
	else if @type = 'S'
		  SET @sql =  @sql + ', MOVE ' + '''' + @LogicalName + ''' TO ''' + @DestDirDbFiles + @LogicalName + '''' + @crlf
set @count = @count + 1
END

SET @sql = left(@sql, len(@sql)-5) + @crlf

--Here's the actual RESTORE command 
if exists (select 1 from #restoreLabel where FamilyCount = 1)
BEGIN
		PRINT @sql 
		--Remove the comment below if you want the procedure to actually execute the restore command. 
		EXEC(@sql)
END
ELSE 
begin
		insert into [#multifilerestore]
		select * , @dirfile BackupLocation , @sql Scripts,getdate() from #restoreLabel
END
waitfor delay '00:00:01'
set @sql = 'drop database ' + QUOTENAME(@dbname)
print @sql
exec sp_executesql @sql 
waitfor delay '00:00:01'
print @dirfile
--exec xp_delete_file 0,@dirfile
CLOSE dbfiles 
FETCH NEXT FROM files INTO @fname 
END 
CLOSE files 
DEALLOCATE dbfiles 
DEALLOCATE files 


DECLARE multirestore CURSOR FOR
select distinct replace(scripts, '''' + backuplocation + '''',  SUBSTRING(
                      (
                          SELECT DISTINCT (', DISK = '''+backuplocation + '''')
                          FROM [#multifilerestore] b
                          WHERE a.mediasetid = b.mediasetid FOR XML PATH('')
                      ), 9, 8000))
					  from [#multifilerestore] a where familysequencenumber = 1

--select * from #dbfiles
OPEN multirestore
FETCH NEXT FROM multirestore INTO @sql
WHILE @@FETCH_STATUS = 0
BEGIN
PRINT @SQL
exec sp_executesql @sql
FETCH NEXT FROM multirestore INTO @sql 
end
CLOSE multirestore 
DEALLOCATE multirestore
drop table #multifilerestore

drop table #multifilerestore


/*
--Copy all backups from multiple folders to one folder.
Set-Location U:\Backups\SmallDB
Get-ChildItem -Path "U:\Backups\SmallDB\*.bak" -Recurse | Move-Item -Destination "U:\Backups\SmallDB\"

$tdc="U:\Backups\SmallDB"
do {
  $dirs = gci $tdc -directory -recurse | Where { (gci $_.fullName).count -eq 0 } | select -expandproperty FullName
  $dirs | Foreach-Object { Remove-Item $_ }
} while ($dirs.count -gt 0)

--Robocopy "\\mycompany\SQL-BACKUPS\" U:\Backups\SmallDB *.bak /MAX:10000000000 /MAXAGE:7 /S /XF "*master*" "*msdb*" "*zDBA*" "*model*" "*pubs*" "*ag_test*" "*view_test*"
*/
