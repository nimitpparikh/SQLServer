DECLARE @tname VARCHAR(128)= 'tablename', @BOUNDARYvalue SQL_VARIANT, @sql NVARCHAR(MAX), @fname VARCHAR(128), @sname VARCHAR(128), @rows BIGINT, @CurrentDate AS DATETIMEOFFSET= DATEADD(dd, 30, SYSDATETIMEOFFSET()), @boundary VARCHAR(MAX);
DECLARE cpartition CURSOR
FOR SELECT t.name TName, 
           r.value PFRange, 
           f.name PFName, 
           S.name PSName, 
           rows RowsCount
    FROM sys.tables AS t
         INNER JOIN sys.indexes AS i ON t.object_id = i.object_id
         INNER JOIN sys.partitions AS p ON i.object_id = p.object_id
                                           AND i.index_id = p.index_id
         INNER JOIN sys.partition_schemes AS s ON i.data_space_id = s.data_space_id
         INNER JOIN sys.partition_functions AS f ON s.function_id = f.function_id
         LEFT OUTER JOIN sys.partition_range_values AS r ON f.function_id = r.function_id
                                                            AND r.boundary_id = p.partition_number
    WHERE 1 = 1
          --  AND t.name = @tname
          AND i.type <= 1
          AND p.partition_number = 1
          AND r.value < DATEADD(DD, -30, GETDATE())
    --AND rows = 0
    ORDER BY p.partition_number;
OPEN cpartition;
FETCH NEXT FROM cpartition INTO @tname, @BOUNDARYvalue, @fname, @sname, @rows;
WHILE @@FETCH_STATUS = 0
    BEGIN
        BEGIN TRY
            SET @sql = 'truncate table ' + @tname + '_switchout';
            EXEC sp_executesql 
                 @sql;
            SET @sql = 'ALTER TABLE ' + QUOTENAME(@tname) + ' SWITCH PARTITION 1 TO  [' + @tname + '_switchout];';
            EXEC sp_executesql 
                 @sql;
        END TRY
        BEGIN CATCH
            PRINT 'Issue with switch ' + @sql;
        END CATCH;
        BEGIN TRY
            IF(SQL_VARIANT_PROPERTY(@BOUNDARYvalue, 'basetype') = 'datetimeoffset')
                SET @boundary = format(CAST(@BOUNDARYvalue AS DATETIMEOFFSET(7)), 'yyyy-MM-dd HH:mm:ss.fffffff zzz');
                ELSE
                SET @boundary = CONVERT(VARCHAR(23), @BOUNDARYvalue, 121);
            SET @sql = 'ALTER PARTITION FUNCTION ' + @fname + ' () MERGE RANGE (''' + @boundary + ''')';
            IF @rows = 0
                BEGIN
                    EXEC sp_executesql 
                         @sql;
                    PRINT @sql;
                END;
        END TRY
        BEGIN CATCH
            SELECT @tname, 
                   @BOUNDARYvalue, 
                   @fname, 
                   @sname, 
                   @rows;
            PRINT 'Merge Range Failed ' + @SQL;
        END CATCH;
        BEGIN TRY
            SET @sql = 'ALTER PARTITION SCHEME ' + @sname + 'NEXT USED [PRIMARY];';
            --PRINT @sql;
            EXEC sp_executesql 
                 @sql;
            SET @sql = 'ALTER PARTITION FUNCTION ' + @fname + ' SPLIT RANGE (''' + CONVERT(VARCHAR(23), @CurrentDate, 121) + ''')';
            --PRINT @SQL;
            EXEC sp_executesql 
                 @sql;
        END TRY
        BEGIN CATCH
            PRINT 'Partition already there;';
        END CATCH;
        FETCH NEXT FROM cpartition INTO @tname, @BOUNDARYvalue, @fname, @sname, @rows;
    END;
CLOSE cpartition;  
DEALLOCATE cpartition;
GO


/*

--Find Partition - Non Aligned Indexes 

SELECT
 ISNULL(db_name(s.database_id),db_name()) AS DBName
 ,OBJECT_SCHEMA_NAME(i.object_id,DB_ID()) AS SchemaName
 ,o.name AS [Object_Name]
 ,i.name AS Index_name
 ,i.Type_Desc AS Type_Desc
 ,ds.name AS DataSpaceName
 ,ds.type_desc AS DataSpaceTypeDesc
 ,s.user_seeks
 ,s.user_scans
 ,s.user_lookups
 ,s.user_updates
 ,s.last_user_seek
 ,s.last_user_update
FROM sys.objects AS o
JOIN sys.indexes AS i ON o.object_id = i.object_id
JOIN sys.data_spaces ds ON ds.data_space_id = i.data_space_id
LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s ON i.object_id = s.object_id AND i.index_id = s.index_id AND s.database_id = DB_ID()
WHERE o.type = 'u'
AND i.type IN (1, 2)
AND o.object_id in
(
 SELECT a.object_id from
 (SELECT ob.object_id, ds.type_desc from sys.objects ob 
 JOIN sys.indexes ind on ind.object_id = ob.object_id 
 JOIN sys.data_spaces ds on ds.data_space_id = ind.data_space_id
 GROUP BY ob.object_id, ds.type_desc ) a 
 GROUP BY a.object_id 
 HAVING COUNT (*) > 1
 )
ORDER BY [Object_Name] DESC;
GO
*/

/*

;WITH CTE_PartCount AS
    (
    SELECT P.object_id
        , P.index_id
        , COUNT(P.partition_number) AS PartitionCount
    FROM sys.partitions AS P
    GROUP BY P.object_id
        , P.index_id
    )
, CTE_Objects AS
    (
    SELECT O.object_id
        , O.name AS ObjectName
        , S.name AS SchemaName
        , I.index_id
        , I.name AS IndexName
        , I.type_desc AS IndexType
    FROM sys.objects AS O
        INNER JOIN sys.schemas AS S ON S.schema_id = O.schema_id
        INNER JOIN sys.indexes AS I ON I.object_id = O.object_id
    WHERE O.is_ms_shipped = 0
        AND O.type_desc = 'USER_TABLE'
    )
, CTE_Summary AS
    (
    SELECT O.object_id
        , O.ObjectName
        , O.SchemaName
        , O.IndexName
        , O.IndexType
        , PC.PartitionCount
        , TablePartCount = FIRST_VALUE(PC.PartitionCount) OVER (PARTITION BY O.object_id ORDER BY O.object_id, O.index_id)
    FROM CTE_Objects AS O
        LEFT OUTER JOIN CTE_PartCount AS PC ON PC.object_id = O.object_id AND PC.index_id = O.index_id
    )
SELECT S.object_id
    , S.SchemaName
    , S.ObjectName
    , S.IndexName
    , S.IndexType
    , S.PartitionCount
    , IsPartitioned = CASE WHEN S.TablePartCount <> 1 THEN 'YES' ELSE 'NO' END
    , IsAligned = CASE WHEN S.TablePartCount = S.PartitionCount THEN 'ALIGNED' ELSE '' END
FROM CTE_Summary AS S

*/
