CREATE PROCEDURE #usp_readerrorlog
(
    @LookBackHours INT = 24, 
    @FilterError VARCHAR(1024) = NULL,
    @StartTime DATETIME = NULL,
    @EndTime DATETIME = NULL,
    @FilterLoginFailed BIT = 1
)
AS
BEGIN
    -- Validate input parameters
    IF @LookBackHours <= 0
    BEGIN
        RAISERROR('LookBackHours must be greater than 0', 16, 1);
        RETURN;
    END

    IF @StartTime IS NOT NULL AND @EndTime IS NOT NULL AND @StartTime > @EndTime
    BEGIN
        RAISERROR('StartTime cannot be greater than EndTime', 16, 1);
        RETURN;
    END

    -- Drop temporary tables if they exist
    IF OBJECT_ID('tempdb..#ErrorLogFiles') IS NOT NULL
        DROP TABLE #ErrorLogFiles;

    CREATE TABLE #ErrorLogFiles
    (
        ArchiveNumber INT,
        LogDate DATETIME,
        LogFileSizeMB INT
    );

    IF OBJECT_ID('tempdb..#ErrorLog') IS NOT NULL
        DROP TABLE #ErrorLog;

    CREATE TABLE #ErrorLog
    (
        LogDate DATETIME,
        ProcessInfo NVARCHAR(50),
        LogText NVARCHAR(MAX)
    );

    -- Insert error log files
    INSERT INTO #ErrorLogFiles
    EXEC xp_enumerrorlogs;

    DECLARE @LogNumber INT;
    DECLARE @MaxLogNumber INT;

    -- Determine the range of log files to parse based on the provided time range
    IF @EndTime IS NOT NULL AND @StartTime IS NULL
    BEGIN
        SET @StartTime = DATEADD(HOUR, -@LookBackHours, @EndTime);
    END

    IF @StartTime IS NOT NULL AND @EndTime IS NOT NULL
    BEGIN
        SET @LogNumber = (
                            SELECT MIN(ArchiveNumber)
                            FROM #ErrorLogFiles
                            WHERE LogDate >= @StartTime
                         );

        SET @MaxLogNumber = (
                                SELECT MAX(ArchiveNumber)
                                FROM #ErrorLogFiles
                                WHERE LogDate <= @EndTime
                            );
    END
    ELSE
    BEGIN
        SET @LogNumber = 0;
        SET @MaxLogNumber = (
                                SELECT MAX(ArchiveNumber)
                                FROM #ErrorLogFiles
                                WHERE LogDate > DATEADD(HOUR, -@LookBackHours, GETDATE())
                            );

        IF @MaxLogNumber IS NULL
            SET @MaxLogNumber = 0
        ELSE
            SET @MaxLogNumber = @MaxLogNumber + 1;
    END

    -- Read error logs
    WHILE @LogNumber <= @MaxLogNumber
    BEGIN
        INSERT INTO #ErrorLog
        (
            LogDate,
            ProcessInfo,
            LogText
        )
        EXEC xp_readerrorlog @LogNumber, 1;

        SET @LogNumber = @LogNumber + 1;
    END;

    -- Delete irrelevant log entries
    DELETE FROM #ErrorLog
    WHERE LogText LIKE '%found 0 errors and repaired 0 errors.%'
          OR LogText LIKE '%No user action is required.%'
          OR LogText LIKE '%command ''BACKUP DATABASE'', operation %'
          OR LogText LIKE 'Buffer Pool scan took %'
          OR LogText LIKE 'Parallel redo is shutdown for database %'
          OR LogText LIKE 'Starting up database %'
          OR LogText LIKE 'Parallel redo is started for database %.'
          OR LogText LIKE 'UTC adjustment:%'
          OR LogText LIKE 'System Manufacturer:%'
          OR LogText LIKE 'Server process ID is%'
          OR LogText LIKE 'Audit: Server Audit:%'
          OR LogText LIKE 'Setting database option%'
          OR LogText LIKE 'Microsoft SQL Server %Microsoft Corporation%Edition%'
          OR LogText LIKE 'Logging SQL Server messages in file%'          
          OR LogText IN ( 'All rights reserved.', '(c) Microsoft Corporation.', 'Authentication mode is MIXED.',
                          'The error log has been reinitialized. See the previous log for older entries.',
                          'Default collation: SQL_Latin1_General_CP1_CI_AS (us_english 1033)'
                        );

    -- Optionally filter login failed errors
    IF @FilterLoginFailed = 1
    BEGIN
        DELETE FROM #ErrorLog
        WHERE LogText LIKE 'Error: 18456, %'
        OR LogText LIKE 'Login failed for user%';
    END

    -- Select relevant log entries based on the provided time range
    IF @StartTime IS NULL AND @EndTime IS NULL
    BEGIN
        SELECT *
        FROM #ErrorLog
        WHERE 
            LogDate > DATEADD(HOUR, -@LookBackHours, GETDATE())
            AND (@FilterError IS NULL OR LogText LIKE '%' + @FilterError + '%')
        ORDER BY LogDate DESC;
    END
    ELSE IF @StartTime IS NULL AND @EndTime IS NOT NULL
    BEGIN
        SELECT *
        FROM #ErrorLog
        WHERE 
            LogDate > DATEADD(HOUR, -@LookBackHours, @EndTime)
            AND LogDate <= @EndTime
            AND (@FilterError IS NULL OR LogText LIKE '%' + @FilterError + '%')
        ORDER BY LogDate DESC;
    END
    ELSE IF @StartTime IS NOT NULL AND @EndTime IS NOT NULL
    BEGIN
        SELECT *
        FROM #ErrorLog
        WHERE 
            LogDate >= @StartTime
            AND LogDate <= @EndTime
            AND (@FilterError IS NULL OR LogText LIKE '%' + @FilterError + '%')
        ORDER BY LogDate DESC;
    END

    -- Drop temporary tables
    DROP TABLE #ErrorLog;
    DROP TABLE #ErrorLogFiles;
END;
GO
EXEC #usp_readerrorlog
GO
DROP PROCEDURE #usp_readerrorlog
